RDD 持久化可以手动选择不同的策略
1. 可以将 RDD 持久化在内存中
2. 持久化在磁盘上
3. 使用序列化的方式持久化
4. 多持久化的数据进行多路复用

只要在调用 persist() 时传入对应的 StorageLevel 即可。


| 持久化          | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| MEMORY_ONLY（默认）     | 直接调用 cache()，以非序列化的 java 对象的方式持久化在 JVM 内存中，如果内存无法完全存储 RDD 所有 partition，那么那些没有持久化的 partition 就会在下一次需要使用它的时候，重新被计算。 |
| MEMORY_AND_DISK | 同上，但是当某些 partition 无法存储在内存中时，会持久化到磁盘，下次需要使用这些 partition 时，需要从磁盘读取。 |
| MEMORY_ONLY_SER | 同 MEMORY_ONLY，但是会使用 Java 序列化方式，将 Java 对象序列化后进行持久化，可以减少内存开销，但是需要进行反序列化，因此会加大 |

### 如何选择 RDD 持久化策略？
Spark 提供多种持久化级别，主要是为了在 CPU 和 内存消耗之间进行取舍。
1. 优先使用 MEMORY_ONLY，如果可以缓存所有数据的话，那么就使用这种策略，因为内存速度快，没有序列化，不需要消耗 CPU 进行反序列化操作。
2. 如果 MEMORY_ONLY 策略无法存储所有数据，选择 MEMORY_ONLY_SER 将数据进行序列化进行存储，纯内存操作还是非常快，只要要消耗 CPU 进行序列化。
3. 如果需要进行快速失败恢复，那么就选择带后缀 _2 的策略进行数据备份，这样在失败时，就不需要重新计算了。
4.能不使用 MEMORY_AND_DISK 就不使用，有时候，还不如重新计算一次。